import type { SiteSetting } from "@/types/payload";
import { fetchFromPayload } from "./client";
import type { PayloadResult, PayloadPaginatedResponse } from "./types";

export class PayloadPublicClient {
  private baseUrl: string;

  constructor(payloadUrl: string) {
    this.baseUrl = payloadUrl;
  }

  /**
   * GENERIC HELPER:
   * Fetch any collection with standard Payload query parameters.
   * Useful for collections you haven't created specific methods for yet.
   */
  async findCollection<T>(
    collectionSlug: string,
    query?: Record<string, any>,
  ): Promise<PayloadResult<PayloadPaginatedResponse<T>>> {
    // Convert query object to query string (basic implementation)
    // In a real app, you might use 'qs' or 'query-string' package for complex "where" clauses
    const searchParams = new URLSearchParams();
    if (query) {
      Object.entries(query).forEach(([key, value]) => {
        searchParams.append(key, String(value));
      });
    }

    const queryString = searchParams.toString();
    const endpoint = `/api/${collectionSlug}${queryString ? `?${queryString}` : ""}`;

    return fetchFromPayload<PayloadPaginatedResponse<T>>(this.baseUrl, {
      endpoint,
      // Public client can cache aggressively
      cache: "force-cache",
    });
  }

  /**
   * SPECIFIC METHOD: Get Pages
   * Optimized for your specific "Pages" collection needs.
   */
  async getPages(options?: {
    depth?: number;
  }): Promise<PayloadResult<PayloadPaginatedResponse<any>>> {
    // Note: Replace 'any' with your actual Page type generated by Payload
    const depth = options?.depth ?? 1; // Default depth 1

    // We explicitly filter for _status: 'published' just to be double-safe,
    // though Payload's access control should handle this too.
    const queryString = `?where[_status][equals]=published&depth=${depth}`;

    return fetchFromPayload<PayloadPaginatedResponse<any>>(this.baseUrl, {
      endpoint: `/api/pages${queryString}`,
      // cache: "force-cache", // Static Generation friendly
    });
  }

  /**
   * SPECIFIC METHOD: Get Page By Slug
   */
  async getPageBySlug(
    slug: string,
    options?: { depth?: number },
  ): Promise<PayloadResult<any | null>> {
    const depth = options?.depth ?? 1;

    // Payload queries need specifically formatted strings for "where"
    // Using simple string construction here for clarity
    const query = `?where[slug][equals]=${slug}&where[_status][equals]=published&depth=${depth}`;

    const result = await fetchFromPayload<PayloadPaginatedResponse<any>>(this.baseUrl, {
      endpoint: `/api/pages${query}`,
      // cache: "force-cache",
    });

    if (!result.success) return result;

    // Return the first doc or null if not found
    const doc = result.data.docs[0] || null;

    return {
      success: true,
      data: doc,
    };
  }

  /**
   * GENERIC HELPER: Fetch a Global (Singleton)
   * e.g. Header, Footer, SiteSettingsc
   */
  async findGlobal<T>(globalSlug: string, options?: { depth?: number }): Promise<PayloadResult<T>> {
    const depth = options?.depth ?? 1;
    const searchParams = new URLSearchParams({
      depth: String(depth),
    });

    return fetchFromPayload<T>(this.baseUrl, {
      endpoint: `/api/globals/${globalSlug}?${searchParams.toString()}`,
      cache: "force-cache",
    });
  }

  async getSiteSettings(): Promise<PayloadResult<SiteSetting>> {
    return this.findGlobal<SiteSetting>("site-settings", { depth: 0 });
  }
}
